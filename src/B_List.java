import java.util.*;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by Fang Yi on 18-1-22.
 */
public class B_List {
    public boolean tt() {
        return false;
    }
    public boolean ss() {
        tt();
        return true;
    }

    public static void main(String[] args) {

//        int[] arr = new int[3];
//        System.out.println(Arrays.copyOfRange(arr, 0, 0).length);
//
//        System.out.println(3.0 == 3.0);
//
////        //analysis and practice of Collection and Map
////
//        ArrayList<Character> list = new ArrayList<>();
//        Character[] b = {'c'};
//
//        list.add('e');
//        list.toArray(b);
//
//
//
//
////        String s = String.valueOf(a);
//        System.out.println(Arrays.toString(b));

//
//        List list1 = new ArrayList<>();
//
//        Vector vector = new Vector();
//
//        Set set = new HashSet<>();
//
//        Map map = new HashMap<>();
//
        Map map1 = new LinkedHashMap<>();
        map1.entrySet().iterator();
//
////        AtomicBoolean atomicBoolean = new AtomicBoolean();
//
//        AtomicInteger atomicInteger = new AtomicInteger();
//
//        ConcurrentHashMap<Integer,String> concurrentHashMap = new ConcurrentHashMap();
//
//        BlockingDeque<String> blockingDeque = new LinkedBlockingDeque<>();
////        System.out.println(args.length);


    }
}
